# 2장. CPU의 구조와 기능
## 2.1. CPU 기본 구조
- ALU (Arithmetic and Logical Unit): 신술 및 논리 연산들을 수행하는 회로들로 이루어진 모듈
- 레지스터 세트 (register set): CPU 내부의 기억 장치로서 액세스 속도가 가장 빠름
- 제어 유닛 (control unit): 인출된 명령어를 해독하고 실행을 위한 신호를 순차 발생 시킴
- 내부 버스 (internal bus): 데이터와 신호들의 전송 통로

## 2.2. 명령어 (instrction) 실행
- 사이클 (cycle): 한개의 명령어를 실행하는 **전체 과정**
    - 인출 사이클
        - 인출 (fetch): 기억장치로부터 명령어를 읽어오는 과정
    - 실행 사이클
        - 실행 (execution): 인출 된 명령어를 실행하는 과정

명령어 수행에는 기본적으로 CPU 내부 레지스터로부터 시작
- Program Counter (PC): 다음 인출 예정인 명령어의 주소를 갖는 레지스터. 인출 이후 자동으로 1만큼 증가. Branch 명령어가 실행된다면 새로운 목적지로 갱신
- Accumulator (AC, 누산기): 데이터를 임시로 저장하는 레지스터. **AC레지스터 비트 수 = 한번에 처리 가능한 데이터 비트 수**
- Instrction Register (IR, 명령어 레지스터): 가장 최근에 호출 된 명령어 저장
- Memory Address Register (MAR): `PC`의 데이터 값을 시스템 주소 버스로 출력 전 임시 저장 장소. **주소 버스와 직접 접촉**
- Memory Buffer Register (MBR): 기억장치에 IO 할 데이터의 임시 저장 장소. **데이터 버스와 직접 접촉**

### 2.2.1. 인출 사이클
`PC`의 값이 111이라면 111에 해당되는 명령어 인출 이후 자동으로 증가. 이 후 112에 해당되는 명령어 인출

1. `PC`의 내용을 내부 버스를 통해 `MAR`로 전송
    - `MAR` 통해 기억장치로 주소 전달 가능 상태
2. 기억 장치로부터 읽은 명령어를 데이터 버스를 통과하여 `MBR`로 전송, 동시에 `PC` 값 명령어 길이 만큼 증가
    - 기억장치의 주소가 8비트, 명령어가 16비트라면 명령어는 2개의 주소 소모. 이로 인해 **1이 아닌 2 증가**
3. `MBR`에 저장된 명령어 코드가 `IR`로 이동

### 2.2.2. 실행 사이클
인출 완료 된 명령어 코드를 Decode 하고, 결과에 따라 연산 수행하는 과정.

#### 데이터 이동
CPU와 IO장치, 기억장치 간 데이터 이동

```
// addr 주소의 데이터를 load 시켜라
LOAD addr
```

1. `IR` 데이터 주소를 `MAR`를 통하여 기억 장치로 전송
2. 기억장치의 해당 주소로부터 데이터 인출 후 `MBR` 저장
3. `AC`에게 데이터 저장

#### 데이터 처리
논리적 산술적 연산 수행

```
// addr 주소의 데이터를 기억장치에 저장 시켜라
STA addr
```

1. `IR` 데이터 주소를 `MAR`로 보낸다
2. `MBR`로 저장할 데이터를 이동시킨다.
    - 이 때 주소와 데이터가 모두 기억 장치로 전달 완료
3. 주소가 지정하는 장소에 데이터 저장

#### 데이터 저장
연산 결과 혹은 Input 된 데이터 기억장치에 저장

```
// addr 주소의 데이터를 AC레지스터의 내용과 더한 뒤 다시 AC레지스터에 저장
ADD addr
```

1. `IR` 데이터 주소를 `MAR`를 통해 기억 장치로 전송
2. 주소에 해당하는 장소로부터 데이터 인출 하여 `MBR`에 저장
3. `AC`에 `AC` + `MBR` 연산 한 값을 저장

#### 프로그램 제어
실행 순서 결정 연산이지만 별도의 명령어가 요구되진 않고, `PC`에 의해 자동 결정. 아예 다른 위치의 명령어를 실행하고 싶은 경우 Branch 사용

```
// addr 주소의 명령어를 PC에 로드
JUMP addr
```

1. `PC`에 `IR(addr)` 값 전달

### 2.2.3. 인터럽트 사이클
순차적 CPU 명령어 실행 중 즉각 중단하고 다른 프로그램 혹은 명령어 수행을 하는 과정. **정전 등의 긴급한 상황에 대처 혹은 외부 장치와 상호 작용**등에 이용    

모든 것은 `ISR(Interrupt Service Routine)`를 실행함으로서 시작 된다. 이를 통해 다른 프로그램을 처리 한 뒤 인터럽트에 대한 처리가 끝나면 원래의 프로그램으로 `return` 한다.

1. 


## 2.3. 명령어 파이프라이닝 (Instruction pipelining)
CPU의 프로그램 처리 속도 증가를 위해 내부 하드웨어를 단계별로 나누어 동시 처리 하는 기술   

### 2.3.1 단계 별 명령어 파이프 라인
#### 2단계 명령어 파이프 라인
- Fetch (인출)과 Execute (실행) stage로 독립적인 파이프라인 모듈로 분리
1. t_0 (첫번째 클록 주기): `인출 단계`가 첫번째 명령어 인출
2. t_1: 첫번째 명령어가 `실행 단계`로 보내져 Execute, 동시에 `인출 단계`는 두번째 명령어 인출

단, 이는 **Fetch와 Execute의 소요 시간이 동일** 할 경우에만 두배 속도 향상. 동일하지 않는 다면 효율 저하
    - 해결책: 파이프라인 단계의 수를 증가 시켜 각 단계의 처리 시간을 같게. 파이프라인 단계 수를 늘리면 속도 향상 효율 증가

#### 4단계 명령어 파이프 라인
1. 명령어 인출(IF): 다음 명령어를 기억장치로부터 인출
2. 명령어 해독(ID): Decoder를 이용하여 명령어 해석
3. 오퍼랜드 인출(OF): 기억장치로부터 오퍼랜드 인출
4. 실행 (EX): 지정된 연산을 수행

### 2.3.2. 파이프라인에 의한 전체 명령어 실행 시간
- 파이프라인 단계 수 = k
- 실행할 명령어들의 수 = N
- 각 파이프 라인 단계가 **한 클럭 주기**씩 걸린다고 가정한다면,
- 파이프라인에 의한 전체 명령어 실행 시간 T_k = K + (N - 1)
    - 첫번쨰 명령어를 실행하는데 k 주기가 소요
    - 나머지 (N - 1)개의 명령어들은 **각각 한주기 씩** 소요
- 파이프 라인이 되지 않은 경우 N개의 명령어 실행 시간 T_1 = k * N

#### 파이프라인에 의한 속도 향상 (Speedup)
```
S_p = T_1 / T_k = (k * N) / {k + (N - 1)}

1Ghz 클럭속도 (1ns) 10개의 명령어 수행 시간 = 4 (첫번째 시간) + (10 - 1) = 13ns
속도 측정: (10 * 4) / 13 = 약 3.08배
```

#### 파이프라인 효율 저하 요인들
- 모든 명령어들이 단계를 모두 필요하지 않는 경우
- 클록은 처리 시간이 가장 오래걸리는 단계를 기준으로 결정 됨
- IF와 OF가 동시에 기억장치 엑세스 상황에서 Memory Conflict (기억장치 충돌)이 일어날 경우 지연 발생
- Conditional Branch (조건 분기)시, 미리 인출하여 처리하던 명령어들 무효화...

#### 분기 발생에 의한 효율 저하 최소화
- Branch Pre-diction (분기 예측): 분기가 일어날 것인지 예측하여, 그에 따라 명령어 인출 (분기 역사 표 참조)
- Prefetch Branch Target (분기 목적지 선인출): 조건 분기 인식시, 다음 명령어 뿐만 아니라 목적지 명령어로 같이 인출
- Loop Buffer 사용: 작은 고속 기억 장치인 루프버퍼에 가장 최근 인출된 n개의 명령어를 순서대로 저장
- Delayed Branch (지연 분기): 분기 명령어의 위치를 재배치 시키기

#### 상태 레지스터 (Status Register)
조건 분기 명령어가 사용할 조건 플래그를 저장.

- 부호(S) 플래그: 직전에 수행된 산술연산 결과값 부호 비트 저장
- 영(Z) 플래그: 연산 결과값이 0일 경우에만 1
- 올림수(C) 플래그: 덧셈이나 뺼셈시 Carray나 Borrow가 발생한 경우 1로 설정
- 동등(E) 플래그: 두 수를 비교한 결과가 같을 경우 1
- 오버플로우(V) 플래그: 연산 과정에서 오버플로우시 1
- 인터럽트(I) 플래그: 인터럽트 가능시 (Interrupt Enabled) 0, 불가능시 1
- 슈퍼바이저(P) 플래그: CPU 실행 모드가 Supervisor Mode 일 경우 1, 아닐 경우 0

### 2.3.3. 슈퍼스칼라 (Superscalar)
파이프라인이 여러개 있는 구조. 매 클록 주기 마다 파이프 라인이 별도의 명령어를 인출.

- 파이프라인의 수 = m: m-way 슈퍼스칼라

#### 속도 향상
- 단일 파이프 라인 실행 시간: T(1) = k + N - 1
- m-way 슈퍼스칼라에 의한 실행 시간: T(m) = k + (N - m / m)
- 속도 향상: Sp = T(1) / T(m)

따라서 **명령어 수 N일 경우 -> 무한대, Sp 시 -> m 으로 해결**

#### 실질적 속도 저하 원인
- 명령어들 간의 데이터 의존 관계
- 하드웨어 (ALU, 레지스터 등) 이용에 대한 경합 발생: 동시 실행 가능 명령어 수 < m

#### 해결책
- 명령어 순서 재배치: 명령어 간 데이터 의존성 제거
- 하드웨어 추가(중복) 설치: 하드웨어 경합 감소

### 2.3.4. 듀얼 코어 및 멀티 코어
한 프로세서 내에 핵심 모듈 (명령어 파이프로 구성된 슈퍼스칼라, ALU 및 레지스터 셋트 등)를 여러개 넣은 것.

- 멀티 테스킹: 독립적인 처리가 가능한 테스크를 코어 별로 동시에 처리 하는 것
- 멀티 쓰레딩: 독립적으로 실행 가능한 최소 크기의 프로그램 단위를 동시 처리 하는 것
    - 여러개의 쓰레드들이 CPU 코어의 하드웨어 자원들을 공유하며 동시에 처리되며, 각각 RS에 저장

## 2.4. 명령어 세트
종류 별로 조금 씩 다른 어떠한 CPU를 위해 정의된 명령어 집합채

우선 아래와 같은 사항들이 선 결정 필수
- 연산 종류: CPU가 수행할 연산의 수 및 복잡도
- 데이터 유형: 데이터의 길이 (비트수), 수 표현 방식 (정수, 부동소수점 수 등)
- 명령어 형식: 명령어의 길이, 오퍼랜드 필드의 개수와 길이 등
- 주소지정 방식: 오퍼랜드의 주소를 지정하는 방식

### 2.4.1. CPU 연산 종류
어떤 컴퓨터든 반드시 수행을 할 수 있어야 하는 기본적인 연산들 목록
- 데이터 전송: 각 장치간 데이터를 이동 하는 동작 (내에 기억장치 주소 계산도 요구)
- 산술 연산: 기본 사칙연산
- 논리 연산: 데이터의 각 비트들 간에 AND, OR, NOT 및 XOR 등 논리 연산
- I/O: CPU와 장치 간에 데이터 이동을 위한 동작
- 프로그램 제어: 명령어 실행 순서를 변경하는 연산
    1. CALL 명령어: 서브루틴을 Call
    2. RET 명령어: 서브루틴으로부터 원래 프로그램으로 return
    3. 위 두 명령어는 SP라는 별도의 스택으로 처리 (되돌아가야 할 곳을 스택)

### 2.4.2. 명령어 형식
각 명령어는 실행시 필요한 모든 정보를 포함하고 있음

- 연산 코드: 수행될 연산을 지정 (LOAD, ADD, SUB 등)
- 오퍼랜드: 연산 수행시 필요한 데이터나 주소
    - 데이터, 기억장치 주소, 레지스터 번호
- 다음 명령어 주소: 현 명령어 실행 완료시 수행할 다음 명령어 위치
    - 단, 순차 실행시 불필요. 분기 혹은 호출 시에 사용
- 명령어 형식: 명령어의 필드 수와 배치 방식 등의 비트 수를 정의 한 것
    - 16비트 CPU라면 4비트 연산코드, 4비트 오퍼랜드1, 8비트 연산코드2 등
    - 연산 코드가 4비트-> 2^4 = 16개 연산 수행 가능
    - 오퍼랜드 필드는 표현 가능한 수, 기억장치 영역 범위, 내부 레지스터 수 등에 의해 결정
    - 오퍼랜드 코드가 1개만 필요하다면 둘이 합쳐 12비트 사용 가능

### 2.4.3. 주소 지정 방식
오퍼랜드 지정 및 더큰 용량의 기억장치를 사용가능하게 하기 위해 존재하는 방식

#### 표기 약속
- EA: Effective Address, 유효 주소, 데이터가 저장된 기억장치의 실제 주소
- A: 명령어 내의 주소 필드 내용 (오퍼렌드가 기억장치 주소인 경우)
- R: 명령어 내의 레지스터 번호 (오퍼랜드가 레지스터 번호 인 경우)
- (A): 기억장치 A번지의 내용
- (R): 레지스터 R의 내용

#### (1) 직접 주소지정 방식
명령어 내 오퍼랜드가 필드 내에 유효 데이터 주소로 직접 사용. `EA = A`

데이터 인출 시 단 한번의 기억장치 엑세스만 필요하며, 별도 절차 불필요. **But,** 명령어 일정 부분이 연산 코드를 위해 사용.

```
명령어의 길이 n bits인 경우 연산 코드의 비트들이 p개라면, 이 방법을 통해 지정 가능한 기억 장소 수는 최대 "2 ^ (n - p)"개 이다.
```

#### (2) 간접 주소지정 방식
명령어 내 오퍼랜드가 필드 내 유효 데이터가 존재하는 주소를 가르킴. `EA = (A)` (= (EA = &A))

이를 통해 기억장치의 범위를 확대 가능. 기존엔 명령어 길이 에서 연산 코드를 제외한 것 