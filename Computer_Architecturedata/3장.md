# 3장. 컴퓨터 산술과 논리 연산
## 3.1. ALU 구성 요소
CPU 내부의 핵심 구성요소로서 산술 연산과 논리 연산을 수행하는 하드웨어

- 산술연산장치: 산술 연산자들을 수행
- 논리연산장치: 논리 연산자들을 수행
- 시프트 레지스터 (Shift Register): 비트들을 좌측 혹은 우측으로 이동
- 보수기 (Complementer): 데이터에 대하여 2의 보수를 취함
- 상태 레지스터 (Status Register): 연산 결과의 상태를 나타내는 Flags 저장 가능

## 3.2. 정수의 표현
Binary Number System에서는 어떤 수를 0과 1, 부호 및 소수점으로 표현

- 부호화 크기 표현 (Singed-Magnitude Representation)
- 1의 보수 표현 (1's Complement Representation)
- 2의 보수 표현 (2's Complement Representation)

### 3.2.1. 부호화-크기 표현
3개의 표현 중 가장 간단 한 것. 수를 표현 하는 단어의 비트 수가 n이라면, 맨 좌측 비트가 부호, 나머지가 수의 크기를 나타냄.

#### 부호화-크기 표현의 결점
1. 덧셈과 뺄셈을 수행하기 위해서는 부호 비트와 크기 부분을 별도로 처리해야함
    1. 두 수의 부호를 비교한다
    2. 부호가 같은 경우 크기 부분을 더하고, 다른 경우 크기 부분의 차이를 구한다.
    3. 크기 부분의 절대값이 더 큰 수의 부호를 결과값의 부호로 Set

### 3.2.2. 보수 표현
음수를 2진수로 표현하는 방법으로서, 1의 보수 및 2의 보수 표현이 있음

- 1의 보수 표현: 모든 비트들을 반전 (-127 ~ 127)
- 2의 보수 표현: 모든 비트들을 반전하고, 결과에 1 더함 (**-128** ~ 128)

연산 과정은 1의 보수가 더 간단하지만, 대부분 2의 보수를 사용하는 이유는 표현 가능 범위가 1만큼 더 크기 때문

### 3.2.3. 부호-비트 확장
2의 보수를 더 긴 단어로 확장할떄 부호 비트를 상위 비트들로 복제하는 동작. 앞에 길이 만큼 상위 비트를 0으로 채우는 것.

```
0101 -> 8비트 확장시 0000 0101
```

## 3.3. 논리 연산
아는 AND, OR, XOR, NOT 연산 생략

A레지스터 = `1001 0010`, B레지스터 = `0000 1111`
- 선택적-세트 연산:
    - B레지스터의 0에 해당하는 자리의 A레지스터 값은 그대로 보존, 1인 구간만 **OR** 연산
    - 따라서 `1001 1111`
- 선택적-보수 연산:
    - B레지스터의 0에 해당하는 자리의 A레지스터 값은 그대로 보존, 1인 구간에서만 **XOR** 연산
    - 따라서 `1001 1101`
- 마스크 연산:
    - B레지스터의 0에 해당되는 자리의 A레지스터 값은 0으로 초기화, 1인 구간에서만 **AND** 연산
    - 따라서 `0000 0010`
- 삽입 연산: A레지스터 = `1001 0101`에 상위 4비트를 `1110`으로 대체 시켜라
    1. 우선 B레지스터 = `0000 1111`로 설정하고, A값과 마스킹 (AND) 연산 처리 -> `0000 0101`
    2. 다음 B레지스터 = `1110 0000`로 상위 4비트를 설정하고, A값과 삽입 (OR) 연산 처리 -> `1110 0101`
    3. 따라서 `1110 0101`
- 비교 연산:
    - 두 값 **XOR** 연산
    - 따라서 `1001 1101`

## 3.4. 시프트 연산
### 3.4.1. 논리적 시프트
값을 모두 이동하고, 빈칸에 `0`을 넣는 것

- 시프트 레지스터: 데이터 비트들을 좌측 혹은 우측으로 이동시키는 기능을 갖음
- 좌측 시프트: 왼쪽으로 한칸씩 이동, 맨 우측 비트 `0`
- 우측 시프트: 최상위 비트 `0`으로 하고 오른쪽으로 한칸씩 이동, 최 하위 비트 버림산
- D 플립-플롭이 대표적 시프트 레지스터

### 3.4.2. 순환 시프트
모든 값을 순환 시키는 것

- 직렬 데이터 전송: 두 레지스터 간에 접속 된 하나의 선을 통하여 데이터를 한 비트 씩 전송
- 좌측 시프트: 왼쪽으로 모든 값 이동 후, 최상위 비트를 최하위 비트로
- 우측 시프트: 오른쪽으로 모든 값 이동 후, 최하위 비트를 최상위 비트로

### 3.4.3. 산술적 시프트
부호를 가진 데이터에 대한 시프트 동작, 부호 비트는 **변경 금지**

- 산술적 좌측 시프트: 최상위 비트는 불변, 그 아래 비트까지만 좌측 시프트
- 산술적 우측 시프트: 최상위 비트는 불변, 그 아래 비트부터 우측 시프트

### 3.4.4. C플래그를 포함한 시프트 연산
일반적인 시프트 연산에는 Carry 값 포함

- C플래그를 포함한 좌측 시프트 (Shift left with carry: SHLC): 기존 C값 버리고, 최상위 비트를 C로 한 좌측 시프트
- C플래그를 포함한 우측 시프트 (Shift Right with carry: SHRC): 기존 C값을 최상위 비트로 한 우측 시프트

## 3.5. 정수의 산술 연산
실제 컴퓨터들은 2의 보수 표현에 대한 산술적 연산을 수행 한다.

### 3.5.1. 덧셈
**오버플로우** 조심! 검출 방법 -> C_4와 C_3을 XOR 연산시 1이 나온다면 (C값이 다르다면) 오버플로우 검출

### 3.5.2. 뺄셈
뺄셈 연산 회로는 별도로 존재하지 않음. 덧셈 회로를 사용하여 연산.

```
A - B = A + (-B)
A - (-B) = A + B
```

### 3.5.3. 곱셈 연산
#### 부호가 없는 경우
일반적 곱과 동일하게 자리수 별로 (Partial Product) 곱연산을 하여 진행 승수와 피승수로 구분.

#### 부호가 있는 경우 (2의 보수간)
Booth 알고리즘을 활용하여 계산

1. 기본 값 초기화: (-7) * 3
    - 피승수 레지스터 M = `1001 (-7)`
    - 승수 레지스터 Q = `0011 (3)`
    - 결과 A = `0000`
    - 계수 (비트 수) n = `4`
    - Q_(-1) = `0`
2. Q_0 Q_(-1) 결과에 따라 아래 따르기
    - `1 0`, A - M -> A로부터 M을 뺀다 (M의 보수를 더한다)
        - A = `0111`, 
    - `0 1`, A + M -> A로부터 M을 더한다
    - `1 1` or `0 0`, 아무것도 하지 않는다.
3. A - Q - Q_(-1)은 산술적 우측 시프트, 계수는 1 감소
    - A = `0011`
    - Q = `1001`
    - Q_(-1) = `1`
    - n = `3`
4. 2번 동작 계수가 0이 될때까지 반복
    1. `1 1`이므로 바로 동작
        - A = `0001`
        - Q = `1100`
        - Q_(-1) = `1`
        - n = `2`
    2. `0 1`이므로 A <- A + M.
        - A = A + M = `0001` + `1001` = `1010`
        - A 산술적 우측 시프트 시 = `1101`
        - Q = `0110`
        - Q_(-1) = `0`
        - n = `1`
    3. `0 0` 이므로 바로 동작
        - A = `1110`
        - Q = `1101`
        - Q_(-1) = `0`
        - n = `0`
5. 계수가 0이므로 종료. A - Q 가 곱 결과 `1110 1101` -> -21

### 3.5.4. 나눗셈
#### 부호가 없는 경우
일방적 나눗셈 동작

#### 부호가 있는 경우 (2의 보수간)
1. 기본 값 초기화: 7 / (-3)
    - M = 제수 = -3의 2의 보수 표현 = `1101`
    - A = `0000`
    - Q = 피제수 = 7 = `0111`
    - n = `4`
2. A - Q 를 좌측-시프트
    - M = `1101`
    - A = `0000`
    - Q = `1110`
    - n = `4`
3. A와 Q의 부호 차에 따라 아래 결과 따르기
    - (A == 0), A <- A - M
    - (A != 0), A <- A + M
4. 4번 동작에 따라 아래 결과 따르기
    - A = 0 || 연산 전 후 A의 부호가 같다면, Q최하위 비트 1
    - A != 0 && 연산 전 후 A의 부호가 틀리면, Q최하위 비트0, 3번 동작을 취소
5. 계수 1 감소 후, 2번 동작 계수가 0이 될때까지 반복
    1. 좌측 시프트
        - M = `1101`
        - A = `0001`
        - Q = `1100`
        - n = `3`
    2. A와 Q의 부호가 다르므로, A  = A + M
        - M = `1101`
        - A = `0001` + `1101` = `1110`
    3. 연산 전 후 부호 틀림 && A != 0 이므로 연산 취소
        - M = `1101`
        - A = `0001`
        - Q = `1101`
        - n = `2`
    4. 좌측 시프트
        - M = `1101`
        - A = `0011`
        - Q = `1000`
        - n = `2`
    5. A와 Q의 부호가 다르므로, A = A + M
        - M = `1101`
        - A = `0011` + `1101` = `0000`
    6. 연산 전 후의 부호가 같으므, Q최 하위 비트 1
        - M = `1101`
        - A = `0011` + `1101` = `0000`
        - Q = `1001`
        - n = `1`
    7. 좌측 시프트
        - M = `1101`
        - A = `0001`
        - Q = `0010`
        - n = `1`
    8. A와 Q의 부호가 같으므로, A = A - M
        - M = `1101`
        - A = `0001` + `0011` = `0100`
    9. 연산 전후의 부호가 같으므로, Q최 하위비트 1
        - M = `1101`
        - A = `0100`
        - Q = `0011`
        - n = `0`
6. Q의 2의 보수가 몫, A의 내용이 나머지 -> `1101` ... `0100` -> `13` ... `4`

## 3.6. 부동소수점 수의 표현
지수를 이용하여 소수점의 위치를 이동 시킬 수 있는 수 표현 방법

- 2진 부동소수점 수: 부동소수점 표현 방식을 적용하여 표현된 2진수
- 단일-정밀도 수: 32비트로 표현된 부동소수점 수
- 복수-정밀도 수: 64비트로 표현된 부동소수점 수
- 정규화된 표현: 소수점 우측의 첫 번째 비트가 1이 되도록 지수를 조정하여 표현한 부동소수점 수
- 